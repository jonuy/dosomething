\hypertarget{group__views__plugins}{
\section{About Views plugins}
\label{group__views__plugins}\index{About Views plugins@{About Views plugins}}
}
In Views, a plugin is a bit like a handler, but plugins are not directly responsible for building the query. Instead, they are objects that are used to display the \hyperlink{classview}{view} or make other modifications.

There are 10 types of plugins in Views:
\begin{DoxyItemize}
\item Display: Display plugins are responsible for controlling $\ast$where$\ast$ a \hyperlink{classview}{view} lives; that is, how they are being exposed to other parts of Drupal. Page and block are the most common displays, as well as the ubiquitous 'master' (or 'default') display.
\item Style: Style plugins control how a \hyperlink{classview}{view} is displayed. For the most part they are object wrappers around theme templates. Styles could for example be HTML lists or tables.
\item Row style: Row styles handle each individual record from the main \hyperlink{classview}{view} table. The two included by default render the entire entity (nodes only), or selected fields.
\item Argument default: Argument default plugins allow pluggable ways of providing default values for contextual filters (previously 'arguments'). This is useful for blocks and other display types lacking a natural argument input. Examples are plugins to extract node and user IDs from the URL.
\item Argument validator: Validator plugins can ensure arguments are valid, and even do transformations on the arguments. They can also provide replacement patterns for the \hyperlink{classview}{view} title. For example, the 'content' validator verifies verifies that the argument value corresponds to a node, loads that node and provides the node title as a replacement pattern.
\item Access: Access plugins are responsible for controlling access to the \hyperlink{classview}{view}. Views includes plugins for checking user roles and individual permissions.
\item \hyperlink{classQuery}{Query}: \hyperlink{classQuery}{Query} plugins generate and execute a query, so they can be seen as a data backend. The default implementation is using SQL. There are contributed modules reading data from other sources, see for example the Views XML Backend module.
\item Cache: Cache plugins control the storage and loading of caches. Currently they can do both result and render caching, but maybe one day cache the generated query.
\item Pager plugins: Pager plugins take care of everything regarding pagers. From getting and setting the total amount of items to render the pager and setting the global pager arrays.
\item Exposed form plugins: Exposed form plugins are responsible for building, rendering and controlling exposed forms. They can expose new parts of the \hyperlink{classview}{view} to the user and more.
\item Localization plugins: Localization plugins take care how the \hyperlink{classview}{view} options are translated. There are example implementations for t(), 'no translation' and i18n.
\item Display extenders: Display extender plugins allow scaling of views options horizontally. This means that you can add options and do stuff on all views displays. One theoretical example is metatags for views.
\end{DoxyItemize}

Plugins are registered by implementing \hyperlink{group__views__hooks_ga23f6e9972b2ed84fc54b7ff63f44477d}{hook\_\-views\_\-plugins()} in your modulename.views.inc file and returning an array of data. For examples please look at \hyperlink{views_2includes_2plugins_8inc_a89b4d3bd8e15dca9a33e85b203218b8d}{views\_\-views\_\-plugins()} in \hyperlink{views_2includes_2plugins_8inc}{views/includes/plugins.inc} as it has examples for all of them.

Similar to handlers, make sure that you add your plugin files to the module.info file.

The array defining plugins will look something like this: 
\begin{DoxyCode}
 return array(
   'display' => array(
     // ... list of display plugins,
    ),
   'style' => array(
     // ... list of style plugins,
    ),
   'row' => array(
     // ... list of row style plugins,
    ),
   'argument default' => array(
     // ... list of argument default plugins,
    ),
   'argument validator' => array(
     // ... list of argument validator plugins,
    ),
    'access' => array(
     // ... list of access plugins,
    ),
    'query' => array(
      // ... list of query plugins,
     ),,
    'cache' => array(
      // ... list of cache plugins,
     ),,
    'pager' => array(
      // ... list of pager plugins,
     ),,
    'exposed_form' => array(
      // ... list of exposed_form plugins,
     ),,
    'localization' => array(
      // ... list of localization plugins,
     ),
    'display_extender' => array(
      // ... list of display extender plugins,
     ),
 );
\end{DoxyCode}


Each plugin will be registered with an identifier for the plugin, plus a fairly lengthy list of items that can define how and where the plugin is used. Here is an example of a row style plugin from Views core: 
\begin{DoxyCode}
     'node' => array(
       'title' => t('Node'),
       'help' => t('Display the node with standard node view.'),
       'handler' => 'views_plugin_row_node_view',
       'path' => drupal_get_path('module', 'views') . '/modules/node', // not nec
      essary for most modules
       'theme' => 'views_view_row_node',
       'base' => array('node'), // only works with 'node' as base.
       'uses options' => TRUE,
       'type' => 'normal',
     ),
\end{DoxyCode}


Of particular interest is the $\ast$path$\ast$ directive, which works a little differently from handler registration; each plugin must define its own path, rather than relying on a global info for the paths. For example: 
\begin{DoxyCode}
    'feed' => array(
      'title' => t('Feed'),
      'help' => t('Display the view as a feed, such as an RSS feed.'),
      'handler' => 'views_plugin_display_feed',
      'uses hook menu' => TRUE,
      'use ajax' => FALSE,
      'use pager' => FALSE,
      'accept attachments' => FALSE,
      'admin' => t('Feed'),
      'help topic' => 'display-feed',
     ),
\end{DoxyCode}


Please be sure to prefix your plugin identifiers with your module name to ensure namespace safety; after all, two different modules could try to implement the 'grid2' plugin, and that would cause one plugin to completely fail.

\begin{Desc}
\item[\hyperlink{todo__todo000088}{Todo}]Finish this document.\end{Desc}
See also:
\begin{DoxyItemize}
\item \hyperlink{group__views__display__plugins}{Views display plugins }
\item \hyperlink{group__views__style__plugins}{Views style plugins }
\item \hyperlink{group__views__row__plugins}{Views row plugins } 
\end{DoxyItemize}