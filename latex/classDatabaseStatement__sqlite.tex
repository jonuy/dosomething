\hypertarget{classDatabaseStatement__sqlite}{
\section{DatabaseStatement\_\-sqlite Class Reference}
\label{classDatabaseStatement__sqlite}\index{DatabaseStatement\_\-sqlite@{DatabaseStatement\_\-sqlite}}
}
Inheritance diagram for DatabaseStatement\_\-sqlite::\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3cm]{classDatabaseStatement__sqlite}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classDatabaseStatement__sqlite_a2b23f3a9e83efae1690475b7c6cda0a8}{execute} (\$args=array(), \$options=array())
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classDatabaseStatement__sqlite_a2d397baba57238e6797e59e9c36943b3}{getStatement} (\$query, \&\$args=array())
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Specific SQLite implementation of \hyperlink{classDatabaseConnection}{DatabaseConnection}.

See \hyperlink{classDatabaseConnection__sqlite_a8e377488ebb6c76e61590ca3f5d7245c}{DatabaseConnection\_\-sqlite::PDOPrepare()} for reasons why we must prefetch the data instead of using PDOStatement.

\begin{DoxySeeAlso}{See also}
\hyperlink{classDatabaseConnection__sqlite_a8e377488ebb6c76e61590ca3f5d7245c}{DatabaseConnection\_\-sqlite::PDOPrepare()} 
\end{DoxySeeAlso}


\subsection{Member Function Documentation}
\hypertarget{classDatabaseStatement__sqlite_a2b23f3a9e83efae1690475b7c6cda0a8}{
\index{DatabaseStatement\_\-sqlite@{DatabaseStatement\_\-sqlite}!execute@{execute}}
\index{execute@{execute}!DatabaseStatement_sqlite@{DatabaseStatement\_\-sqlite}}
\subsubsection[{execute}]{\setlength{\rightskip}{0pt plus 5cm}DatabaseStatement\_\-sqlite::execute (\$ {\em args} = {\ttfamily array()}, \/  \$ {\em options} = {\ttfamily array()})}}
\label{classDatabaseStatement__sqlite_a2b23f3a9e83efae1690475b7c6cda0a8}
Executes a prepared statement


\begin{DoxyParams}{Parameters}
\item[{\em \$args}]An array of values with as many elements as there are bound parameters in the SQL statement being executed. \item[{\em \$options}]An array of options for this query.\end{DoxyParams}
\begin{DoxyReturn}{Returns}
TRUE on success, or FALSE on failure. 
\end{DoxyReturn}


Implements \hyperlink{interfaceDatabaseStatementInterface_a716e454a44a7667f7a90b90c1a6fe3eb}{DatabaseStatementInterface}.\hypertarget{classDatabaseStatement__sqlite_a2d397baba57238e6797e59e9c36943b3}{
\index{DatabaseStatement\_\-sqlite@{DatabaseStatement\_\-sqlite}!getStatement@{getStatement}}
\index{getStatement@{getStatement}!DatabaseStatement_sqlite@{DatabaseStatement\_\-sqlite}}
\subsubsection[{getStatement}]{\setlength{\rightskip}{0pt plus 5cm}DatabaseStatement\_\-sqlite::getStatement (\$ {\em query}, \/  \&\$ {\em args} = {\ttfamily array()})\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classDatabaseStatement__sqlite_a2d397baba57238e6797e59e9c36943b3}
SQLite specific implementation of \hyperlink{classDatabaseStatement__sqlite_a2d397baba57238e6797e59e9c36943b3}{getStatement()}.

The PDO SQLite layer doesn't replace numeric placeholders in queries correctly, and this makes numeric expressions (such as COUNT($\ast$) $>$= :count) fail. We replace numeric placeholders in the query ourselves to work around this bug.

See \href{http://bugs.php.net/bug.php?id=45259}{\tt http://bugs.php.net/bug.php?id=45259} for more details. 

Reimplemented from \hyperlink{classDatabaseStatementPrefetch_a08ef92c5108225cdd2e02885ca2aeea4}{DatabaseStatementPrefetch}.

The documentation for this class was generated from the following file:\begin{DoxyCompactItemize}
\item 
html/includes/database/sqlite/\hyperlink{sqlite_2database_8inc}{database.inc}\end{DoxyCompactItemize}
