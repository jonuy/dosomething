\hypertarget{classMemoryQueue}{
\section{MemoryQueue Class Reference}
\label{classMemoryQueue}\index{MemoryQueue@{MemoryQueue}}
}
Inheritance diagram for MemoryQueue::\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3cm]{classMemoryQueue}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classMemoryQueue_a83e620eced2895763ebad69f615462b2}{\_\-\_\-construct} (\$name)
\item 
\hyperlink{classMemoryQueue_a5d8fe8085407a1a77c505ba8532b9c50}{createItem} (\$data)
\item 
\hyperlink{classMemoryQueue_a266edfebcf6567707f3e2dafc3200491}{numberOfItems} ()
\item 
\hyperlink{classMemoryQueue_a24cba156a854a7b4b6c81c3d2614508d}{claimItem} (\$lease\_\-time=30)
\item 
\hyperlink{classMemoryQueue_a3091327204bb8b2e9c13baf32142f7f5}{deleteItem} (\$item)
\item 
\hyperlink{classMemoryQueue_ad835863a58ca48f31f8cb1e3807b88cf}{releaseItem} (\$item)
\item 
\hyperlink{classMemoryQueue_a94e1da7e8b4cccb445acb8500e0b39a5}{createQueue} ()
\item 
\hyperlink{classMemoryQueue_a055cd4bf4b319accf5ffa2c6f22685f1}{deleteQueue} ()
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classMemoryQueue_a7c2d4dee239a697d91541bc1ad580eb4}{
{\bfseries \$queue}}
\label{classMemoryQueue_a7c2d4dee239a697d91541bc1ad580eb4}

\item 
\hypertarget{classMemoryQueue_aead361610d119b99b7e9f11fd46e008a}{
{\bfseries \$id\_\-sequence}}
\label{classMemoryQueue_aead361610d119b99b7e9f11fd46e008a}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Static queue implementation.

This allows \char`\"{}undelayed\char`\"{} variants of processes relying on the Queue interface. The queue data resides in memory. It should only be used for items that will be queued and dequeued within a given page request. 

\subsection{Constructor \& Destructor Documentation}
\hypertarget{classMemoryQueue_a83e620eced2895763ebad69f615462b2}{
\index{MemoryQueue@{MemoryQueue}!\_\-\_\-construct@{\_\-\_\-construct}}
\index{\_\-\_\-construct@{\_\-\_\-construct}!MemoryQueue@{MemoryQueue}}
\subsubsection[{\_\-\_\-construct}]{\setlength{\rightskip}{0pt plus 5cm}MemoryQueue::\_\-\_\-construct (\$ {\em name})}}
\label{classMemoryQueue_a83e620eced2895763ebad69f615462b2}
Start working with a queue.


\begin{DoxyParams}{Parameters}
\item[{\em \$name}]Arbitrary string. The name of the queue to work with. \end{DoxyParams}


\subsection{Member Function Documentation}
\hypertarget{classMemoryQueue_a24cba156a854a7b4b6c81c3d2614508d}{
\index{MemoryQueue@{MemoryQueue}!claimItem@{claimItem}}
\index{claimItem@{claimItem}!MemoryQueue@{MemoryQueue}}
\subsubsection[{claimItem}]{\setlength{\rightskip}{0pt plus 5cm}MemoryQueue::claimItem (\$ {\em lease\_\-time} = {\ttfamily 30})}}
\label{classMemoryQueue_a24cba156a854a7b4b6c81c3d2614508d}
Claim an item in the queue for processing.


\begin{DoxyParams}{Parameters}
\item[{\em \$lease\_\-time}]How long the processing is expected to take in seconds, defaults to an hour. After this lease expires, the item will be reset and another consumer can claim the item. For idempotent tasks (which can be run multiple times without side effects), shorter lease times would result in lower latency in case a consumer fails. For tasks that should not be run more than once (non-\/idempotent), a larger lease time will make it more rare for a given task to run multiple times in cases of failure, at the cost of higher latency. \end{DoxyParams}
\begin{DoxyReturn}{Returns}
On success we return an item object. If the queue is unable to claim an item it returns false. This implies a best effort to retrieve an item and either the queue is empty or there is some other non-\/recoverable problem. 
\end{DoxyReturn}


Implements \hyperlink{interfaceDrupalQueueInterface_a2f0f2ccc1f4d55c0890897ea85e75954}{DrupalQueueInterface}.

Reimplemented in \hyperlink{classBatchMemoryQueue_aca687797fff1fee4a86293e8c32190ad}{BatchMemoryQueue}.\hypertarget{classMemoryQueue_a5d8fe8085407a1a77c505ba8532b9c50}{
\index{MemoryQueue@{MemoryQueue}!createItem@{createItem}}
\index{createItem@{createItem}!MemoryQueue@{MemoryQueue}}
\subsubsection[{createItem}]{\setlength{\rightskip}{0pt plus 5cm}MemoryQueue::createItem (\$ {\em data})}}
\label{classMemoryQueue_a5d8fe8085407a1a77c505ba8532b9c50}
Add a queue item and store it directly to the queue.


\begin{DoxyParams}{Parameters}
\item[{\em \$data}]Arbitrary data to be associated with the new task in the queue. \end{DoxyParams}
\begin{DoxyReturn}{Returns}
TRUE if the item was successfully created and was (best effort) added to the queue, otherwise FALSE. We don't guarantee the item was committed to disk etc, but as far as we know, the item is now in the queue. 
\end{DoxyReturn}


Implements \hyperlink{interfaceDrupalQueueInterface_a1bdef6341808aaf8b3de821b7b71f137}{DrupalQueueInterface}.\hypertarget{classMemoryQueue_a94e1da7e8b4cccb445acb8500e0b39a5}{
\index{MemoryQueue@{MemoryQueue}!createQueue@{createQueue}}
\index{createQueue@{createQueue}!MemoryQueue@{MemoryQueue}}
\subsubsection[{createQueue}]{\setlength{\rightskip}{0pt plus 5cm}MemoryQueue::createQueue ()}}
\label{classMemoryQueue_a94e1da7e8b4cccb445acb8500e0b39a5}
Create a queue.

Called during installation and should be used to perform any necessary initialization operations. This should not be confused with the constructor for these objects, which is called every time an object is instantiated to operate on a queue. This operation is only needed the first time a given queue is going to be initialized (for example, to make a new database table or directory to hold tasks for the queue -\/-\/ it depends on the queue implementation if this is necessary at all). 

Implements \hyperlink{interfaceDrupalQueueInterface_a5a657d8c1d5bb429b3e594fa0c883ad3}{DrupalQueueInterface}.\hypertarget{classMemoryQueue_a3091327204bb8b2e9c13baf32142f7f5}{
\index{MemoryQueue@{MemoryQueue}!deleteItem@{deleteItem}}
\index{deleteItem@{deleteItem}!MemoryQueue@{MemoryQueue}}
\subsubsection[{deleteItem}]{\setlength{\rightskip}{0pt plus 5cm}MemoryQueue::deleteItem (\$ {\em item})}}
\label{classMemoryQueue_a3091327204bb8b2e9c13baf32142f7f5}
Delete a finished item from the queue.


\begin{DoxyParams}{Parameters}
\item[{\em \$item}]The item returned by \hyperlink{interfaceDrupalQueueInterface_a2f0f2ccc1f4d55c0890897ea85e75954}{DrupalQueueInterface::claimItem()}. \end{DoxyParams}


Implements \hyperlink{interfaceDrupalQueueInterface_aa61212089c1bcc410e8f87f8e619e351}{DrupalQueueInterface}.\hypertarget{classMemoryQueue_a055cd4bf4b319accf5ffa2c6f22685f1}{
\index{MemoryQueue@{MemoryQueue}!deleteQueue@{deleteQueue}}
\index{deleteQueue@{deleteQueue}!MemoryQueue@{MemoryQueue}}
\subsubsection[{deleteQueue}]{\setlength{\rightskip}{0pt plus 5cm}MemoryQueue::deleteQueue ()}}
\label{classMemoryQueue_a055cd4bf4b319accf5ffa2c6f22685f1}
Delete a queue and every item in the queue. 

Implements \hyperlink{interfaceDrupalQueueInterface_ad403fed96dbd86e64a8a48c33fe5f2bc}{DrupalQueueInterface}.\hypertarget{classMemoryQueue_a266edfebcf6567707f3e2dafc3200491}{
\index{MemoryQueue@{MemoryQueue}!numberOfItems@{numberOfItems}}
\index{numberOfItems@{numberOfItems}!MemoryQueue@{MemoryQueue}}
\subsubsection[{numberOfItems}]{\setlength{\rightskip}{0pt plus 5cm}MemoryQueue::numberOfItems ()}}
\label{classMemoryQueue_a266edfebcf6567707f3e2dafc3200491}
Retrieve the number of items in the queue.

This is intended to provide a \char`\"{}best guess\char`\"{} count of the number of items in the queue. Depending on the implementation and the setup, the accuracy of the results of this function may vary.

e.g. On a busy system with a large number of consumers and items, the result might only be valid for a fraction of a second and not provide an accurate representation.

\begin{DoxyReturn}{Returns}
An integer estimate of the number of items in the queue. 
\end{DoxyReturn}


Implements \hyperlink{interfaceDrupalQueueInterface_aee5a22d355c9e6246690d0ed79fe306b}{DrupalQueueInterface}.\hypertarget{classMemoryQueue_ad835863a58ca48f31f8cb1e3807b88cf}{
\index{MemoryQueue@{MemoryQueue}!releaseItem@{releaseItem}}
\index{releaseItem@{releaseItem}!MemoryQueue@{MemoryQueue}}
\subsubsection[{releaseItem}]{\setlength{\rightskip}{0pt plus 5cm}MemoryQueue::releaseItem (\$ {\em item})}}
\label{classMemoryQueue_ad835863a58ca48f31f8cb1e3807b88cf}
Release an item that the worker could not process, so another worker can come in and process it before the timeout expires.


\begin{DoxyParams}{Parameters}
\item[{\em \$item}]\end{DoxyParams}
\begin{DoxyReturn}{Returns}
boolean 
\end{DoxyReturn}


Implements \hyperlink{interfaceDrupalQueueInterface_a7f4ce9d592779327cd24dbf90566da67}{DrupalQueueInterface}.

The documentation for this class was generated from the following file:\begin{DoxyCompactItemize}
\item 
html/modules/system/\hyperlink{system_8queue_8inc}{system.queue.inc}\end{DoxyCompactItemize}
