<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DoSomething.org: Locking mechanisms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Locking mechanisms</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lock.html#ga8e0cf09d86196c0a26b50df3567108a4">lock_initialize</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lock.html#ga22f64c6b65bc54d5f8f981559b0cdf04">_lock_id</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lock.html#gac67a4b1061491f7a869646f47b66e998">lock_acquire</a> ($name, $timeout=30.0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lock.html#ga095b65838e63b109f52ff6d8c00d8963">lock_may_be_available</a> ($name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lock.html#ga54c2ee771edac47614b8f12d949d3376">lock_wait</a> ($name, $delay=30)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lock.html#ga73e1456861f9aff1a506a650f43aceb0">lock_release</a> ($name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lock.html#ga290817e14e2a9ecc0bd34c6b7b0af031">lock_release_all</a> ($lock_id=NULL)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Functions to coordinate long-running operations across requests.</p>
<p>In most environments, multiple Drupal page requests (a.k.a. threads or processes) will execute in parallel. This leads to potential conflicts or race conditions when two requests execute the same code at the same time. A common example of this is a rebuild like <a class="el" href="group__menu.html#gaf36dcb9d5491ef5e7d2cf22c1f5c69f4">menu_rebuild()</a> where we invoke many hook implementations to get and process data from all active modules, and then delete the current data in the database to insert the new afterwards.</p>
<p>This is a cooperative, advisory lock system. Any long-running operation that could potentially be attempted in parallel by multiple requests should try to acquire a lock before proceeding. By obtaining a lock, one request notifies any other requests that a specific operation is in progress which must not be executed in parallel.</p>
<p>To use this API, pick a unique name for the lock. A sensible choice is the name of the function performing the operation. A very simple example use of this API: </p>
<div class="fragment"><pre class="fragment"> function mymodule_long_operation() {
   <span class="keywordflow">if</span> (<a class="code" href="group__lock.html#gac67a4b1061491f7a869646f47b66e998">lock_acquire</a>(<span class="stringliteral">&apos;mymodule_long_operation&apos;</span>)) {
     <span class="comment">// Do the long operation here.</span>
     <span class="comment">// ...</span>
     <a class="code" href="group__lock.html#ga73e1456861f9aff1a506a650f43aceb0">lock_release</a>(<span class="stringliteral">&apos;mymodule_long_operation&apos;</span>);
   }
 }
</pre></div><p>If a function acquires a lock it should always release it when the operation is complete by calling <a class="el" href="group__lock.html#ga73e1456861f9aff1a506a650f43aceb0">lock_release()</a>, as in the example.</p>
<p>A function that has acquired a lock may attempt to renew a lock (extend the duration of the lock) by calling <a class="el" href="group__lock.html#gac67a4b1061491f7a869646f47b66e998">lock_acquire()</a> again during the operation. Failure to renew a lock is indicative that another request has acquired the lock, and that the current operation may need to be aborted.</p>
<p>If a function fails to acquire a lock it may either immediately return, or it may call <a class="el" href="group__lock.html#ga54c2ee771edac47614b8f12d949d3376">lock_wait()</a> if the rest of the current page request requires that the operation in question be complete. After <a class="el" href="group__lock.html#ga54c2ee771edac47614b8f12d949d3376">lock_wait()</a> returns, the function may again attempt to acquire the lock, or may simply allow the page request to proceed on the assumption that a parallel request completed the operation.</p>
<p><a class="el" href="group__lock.html#gac67a4b1061491f7a869646f47b66e998">lock_acquire()</a> and <a class="el" href="group__lock.html#ga54c2ee771edac47614b8f12d949d3376">lock_wait()</a> will automatically break (delete) a lock whose duration has exceeded the timeout specified when it was acquired.</p>
<p>Alternative implementations of this API (such as APC) may be substituted by setting the 'lock_inc' variable to an alternate include filepath. Since this is an API intended to support alternative implementations, code using this API should never rely upon specific implementation details (for example no code should look for or directly modify a lock in the {semaphore} table). </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga22f64c6b65bc54d5f8f981559b0cdf04"></a><!-- doxytag: member="lock.inc::_lock_id" ref="ga22f64c6b65bc54d5f8f981559b0cdf04" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_lock_id </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper function to get this request's unique id. </p>

</div>
</div>
<a class="anchor" id="gac67a4b1061491f7a869646f47b66e998"></a><!-- doxytag: member="lock.inc::lock_acquire" ref="gac67a4b1061491f7a869646f47b66e998" args="($name, $timeout=30.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lock_acquire </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>30.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acquire (or renew) a lock, but do not block if it fails.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$name</em>&nbsp;</td><td>The name of the lock. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$timeout</em>&nbsp;</td><td>A number of seconds (float) before the lock expires (minimum of 0.001).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the lock was acquired, FALSE if it failed. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e0cf09d86196c0a26b50df3567108a4"></a><!-- doxytag: member="lock.inc::lock_initialize" ref="ga8e0cf09d86196c0a26b50df3567108a4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lock_initialize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the locking system. </p>

</div>
</div>
<a class="anchor" id="ga095b65838e63b109f52ff6d8c00d8963"></a><!-- doxytag: member="lock.inc::lock_may_be_available" ref="ga095b65838e63b109f52ff6d8c00d8963" args="($name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lock_may_be_available </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if lock acquired by a different process may be available.</p>
<p>If an existing lock has expired, it is removed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$name</em>&nbsp;</td><td>The name of the lock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if there is no lock or it was removed, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga73e1456861f9aff1a506a650f43aceb0"></a><!-- doxytag: member="lock.inc::lock_release" ref="ga73e1456861f9aff1a506a650f43aceb0" args="($name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lock_release </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release a lock previously acquired by <a class="el" href="group__lock.html#gac67a4b1061491f7a869646f47b66e998">lock_acquire()</a>.</p>
<p>This will release the named lock if it is still held by the current request.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$name</em>&nbsp;</td><td>The name of the lock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga290817e14e2a9ecc0bd34c6b7b0af031"></a><!-- doxytag: member="lock.inc::lock_release_all" ref="ga290817e14e2a9ecc0bd34c6b7b0af031" args="($lock_id=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lock_release_all </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>lock_id</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release all previously acquired locks. </p>

</div>
</div>
<a class="anchor" id="ga54c2ee771edac47614b8f12d949d3376"></a><!-- doxytag: member="lock.inc::lock_wait" ref="ga54c2ee771edac47614b8f12d949d3376" args="($name, $delay=30)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lock_wait </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>delay</em> = <code>30</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wait for a lock to be available.</p>
<p>This function may be called in a request that fails to acquire a desired lock. This will block further execution until the lock is available or the specified delay in seconds is reached. This should not be used with locks that are acquired very frequently, since the lock is likely to be acquired again by a different request while waiting.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$name</em>&nbsp;</td><td>The name of the lock. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$delay</em>&nbsp;</td><td>The maximum number of seconds to wait, as an integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the lock holds, FALSE if it is available. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 8 Nov 2013 for DoSomething.org by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
