<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DoSomething.org: Node access rights</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Node access rights</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node__access.html#gaa973f2ab6ab14c3fa14e5138c6d69ecf">hook_node_grants</a> ($account, $op)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node__access.html#ga3fe7744d74446e40e9b9ad2a782b4269">hook_node_access_records</a> ($node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node__access.html#ga37c90bf0e1dccad0deefa368dd94cc83">hook_node_access_records_alter</a> (&amp;$grants, $node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node__access.html#ga21e95e2bd0b4ed12d861aa83426a8ba3">hook_node_grants_alter</a> (&amp;$grants, $account, $op)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node__access.html#ga75a280ea1fbe0fb6ca034f8aad06d58d">hook_node_access</a> ($node, $op, $account)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node__access.html#ga46f0f1ed812befada8f8e7d1b8c352db">node_access</a> ($op, $node, $account=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node__access.html#gae826daeafed8b20300a370c2022cc2c1">node_node_access</a> ($node, $op, $account)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node__access.html#ga929efd16564e3cb073ee5e1ed6c6c2a7">node_list_permissions</a> ($type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node__access.html#ga75960e1cc5852c75c6347ab938938f9b">node_permissions_get_configured_types</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node__access.html#gab33de8c23b1edb657f67cb242a8ec8af">node_access_grants</a> ($op, $account=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node__access.html#gafb79200147d5087ceb32cb6b0632afd4">node_access_view_all_nodes</a> ($account=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node__access.html#gaef7c83544718b8431d81b884ef8cc6f5">node_query_node_access_alter</a> (<a class="el" href="interfaceQueryAlterableInterface.html">QueryAlterableInterface</a> $query)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node__access.html#gacd4162ac9ee2d2147d5212fd5e7a7319">node_query_entity_field_access_alter</a> (<a class="el" href="interfaceQueryAlterableInterface.html">QueryAlterableInterface</a> $query)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node__access.html#ga5f4838d9b5cac9f3bee9a26f39e80691">_node_query_node_access_alter</a> ($query, $type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node__access.html#ga6fbbc13a4098f72663c0a67f81100f67">node_access_acquire_grants</a> ($node, $delete=TRUE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node__access.html#ga735fbb5dfa05cc1aed121655a1694909">node_access_write_grants</a> ($node, $grants, $realm=NULL, $delete=TRUE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node__access.html#ga895d95595168709334c4eca1472c6d23">node_access_needs_rebuild</a> ($rebuild=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node__access.html#gaf04007aedfc3afbe074b2fe4065ab618">node_access_rebuild</a> ($batch_mode=FALSE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node__access.html#ga2b720b31a5b728b16c357ab995deb5d5">_node_access_rebuild_batch_operation</a> (&amp;$context)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node__access.html#gaa7feee934ce635e386628b570901ff38">_node_access_rebuild_batch_finished</a> ($success, $results, $operations)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node__access.html#gaeedf3adea0813fb3631f26d0de83a68d">hook_node_access_explain</a> ($row)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node__access.html#gac5a197ac3564b867c2921fb496063ae6">hook_node_access_acknowledge</a> ($grant)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The node access system determines who can do what to which nodes.</p>
<p>In determining access rights for a node, <a class="el" href="group__node__access.html#ga46f0f1ed812befada8f8e7d1b8c352db">node_access()</a> first checks whether the user has the "bypass node access" permission. Such users have unrestricted access to all nodes. user 1 will always pass this check.</p>
<p>Next, all implementations of <a class="el" href="group__node__access.html#ga75a280ea1fbe0fb6ca034f8aad06d58d">hook_node_access()</a> will be called. Each implementation may explicitly allow, explicitly deny, or ignore the access request. If at least one module says to deny the request, it will be rejected. If no modules deny the request and at least one says to allow it, the request will be permitted.</p>
<p>If all modules ignore the access request, then the node_access table is used to determine access. All node access modules are queried using <a class="el" href="group__node__access.html#gaa973f2ab6ab14c3fa14e5138c6d69ecf">hook_node_grants()</a> to assemble a list of "grant IDs" for the user. This list is compared against the table. If any row contains the node ID in question (or 0, which stands for "all nodes"), one of the grant IDs returned, and a value of TRUE for the operation in question, then access is granted. Note that this table is a list of grants; any matching row is sufficient to grant access to the node.</p>
<p>In node listings (lists of nodes generated from a select query, such as the default home page at path 'node', an RSS feed, a recent content block, etc.), the process above is followed except that <a class="el" href="group__node__access.html#ga75a280ea1fbe0fb6ca034f8aad06d58d">hook_node_access()</a> is not called on each node for performance reasons and for proper functioning of the pager system. When adding a node listing to your module, be sure to use a dynamic query created by <a class="el" href="group__database.html#ga9e030cee657d64e3d8e524c65814cc9f">db_select()</a> and add a tag of "node_access". This will allow modules dealing with node access to ensure only nodes to which the user has access are retrieved, through the use of <a class="el" href="group__hooks.html#ga12527037deeb76adcab1000e984fdfce">hook_query_TAG_alter()</a>.</p>
<p>Note: Even a single module returning NODE_ACCESS_DENY from <a class="el" href="group__node__access.html#ga75a280ea1fbe0fb6ca034f8aad06d58d">hook_node_access()</a> will block access to the node. Therefore, implementers should take care to not deny access unless they really intend to. Unless a module wishes to actively deny access it should return NODE_ACCESS_IGNORE (or simply return nothing) to allow other modules or the node_access table to control access.</p>
<p>To see how to write a node access module of your own, see node_access_example.module. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaa7feee934ce635e386628b570901ff38"></a><!-- doxytag: member="node.module::_node_access_rebuild_batch_finished" ref="gaa7feee934ce635e386628b570901ff38" args="($success, $results, $operations)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_node_access_rebuild_batch_finished </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>operations</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Performs post-processing for <a class="el" href="group__node__access.html#gaf04007aedfc3afbe074b2fe4065ab618">node_access_rebuild()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bool</em>&nbsp;</td><td>$success A boolean indicating whether the re-build process has completed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>$results An array of results information. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>$operations An array of function calls (not used in this function). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2b720b31a5b728b16c357ab995deb5d5"></a><!-- doxytag: member="node.module::_node_access_rebuild_batch_operation" ref="ga2b720b31a5b728b16c357ab995deb5d5" args="(&amp;$context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_node_access_rebuild_batch_operation </td>
          <td>(</td>
          <td class="paramtype">&amp;$&nbsp;</td>
          <td class="paramname"> <em>context</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Performs batch operation for <a class="el" href="group__node__access.html#gaf04007aedfc3afbe074b2fe4065ab618">node_access_rebuild()</a>.</p>
<p>This is a multistep operation: we go through all nodes by packs of 20. The batch processing engine interrupts processing and sends progress feedback after 1 second execution time.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>$context An array of contextual key/value information for rebuild batch process. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5f4838d9b5cac9f3bee9a26f39e80691"></a><!-- doxytag: member="node.module::_node_query_node_access_alter" ref="ga5f4838d9b5cac9f3bee9a26f39e80691" args="($query, $type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_node_query_node_access_alter </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper for node access functions.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$query</em>&nbsp;</td><td>The query to add conditions to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$type</em>&nbsp;</td><td>Either 'node' or 'entity' depending on what sort of query it is. See <a class="el" href="group__node__access.html#gaef7c83544718b8431d81b884ef8cc6f5">node_query_node_access_alter()</a> and <a class="el" href="group__node__access.html#gacd4162ac9ee2d2147d5212fd5e7a7319">node_query_entity_field_access_alter()</a> for more. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga75a280ea1fbe0fb6ca034f8aad06d58d"></a><!-- doxytag: member="node.api.php::hook_node_access" ref="ga75a280ea1fbe0fb6ca034f8aad06d58d" args="($node, $op, $account)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hook_node_access </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>account</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Control access to a node.</p>
<p>Modules may implement this hook if they want to have a say in whether or not a given user has access to perform a given operation on a node.</p>
<p>The administrative account (user ID #1) always passes any access check, so this hook is not called in that case. Users with the "bypass node access" permission may always <a class="el" href="classview.html">view</a> and edit content through the administrative interface.</p>
<p>Note that not all modules will want to influence access on all node types. If your module does not want to actively grant or block access, return NODE_ACCESS_IGNORE or simply return nothing. Blindly returning FALSE will break other node access modules.</p>
<p>Also note that this function isn't called for node listings (e.g., RSS feeds, the default home page at path 'node', a recent content block, etc.) See <a class="el" href="group__node__access.html">Node access rights </a> for a full explanation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$node</em>&nbsp;</td><td>Either a node object or the machine name of the content type on which to perform the access check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$op</em>&nbsp;</td><td>The operation to be performed. Possible values:</p>
<ul>
<li>"create"</li>
<li>"delete"</li>
<li>"update"</li>
<li>"view" </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$account</em>&nbsp;</td><td>The user object to perform the access check operation on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>NODE_ACCESS_ALLOW: if the operation is to be allowed.</li>
<li>NODE_ACCESS_DENY: if the operation is to be denied.</li>
<li>NODE_ACCESS_IGNORE: to not affect this operation at all. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gac5a197ac3564b867c2921fb496063ae6"></a><!-- doxytag: member="devel_node_access.api.php::hook_node_access_acknowledge" ref="gac5a197ac3564b867c2921fb496063ae6" args="($grant)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hook_node_access_acknowledge </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>grant</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acknowledge ownership of 'alien' grant records.</p>
<p>Some node access modules store grant records directly into the {node_access} table rather than returning them through <a class="el" href="group__node__access.html#ga3fe7744d74446e40e9b9ad2a782b4269">hook_node_access_records()</a>. This practice is not recommended and DNA will flag all such records as 'alien'.</p>
<p>If this is unavoidable, a module can confess to being the owner of these grant records, so that DNA can properly attribute them.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__node__access.html#ga3fe7744d74446e40e9b9ad2a782b4269">hook_node_access_records()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaeedf3adea0813fb3631f26d0de83a68d"></a><!-- doxytag: member="devel_node_access.api.php::hook_node_access_explain" ref="gaeedf3adea0813fb3631f26d0de83a68d" args="($row)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hook_node_access_explain </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>row</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Explain your records in the {node_access} table.</p>
<p>In order to help developers and administrators understand the forces that control access to any given node, the DNA module provides the Devel Node Access block, which lists all the grant records in the {node_access} table for that node.</p>
<p>However, every Node Access module is free in how it defines and uses the 'realm' and 'gid' fields in its records in the {node_access} table, and it's often difficult to interpret them. This hook passes each record that DNA wants to display, and the owning module is expected to return an explanation of that record.</p>
<p>The explanation should not be localized (not be passed through t()), so that administrators seeking help can present English explanations.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$row</em>&nbsp;</td><td>The record from the {node_access} table, as object. The member fields are: nid, gid, realm, grant_view, grant_update, grant_delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A string with a (short!) explanation of the given {node_access} row, to be displayed in DNA's 'Devel Node Access' block. It will be displayed as HTML; any variable parts must already be sanitized.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__node__access.html#ga3fe7744d74446e40e9b9ad2a782b4269">hook_node_access_records()</a> </dd>
<dd>
<a class="el" href="devel__node__access_8module.html#a7b594d5b01b220abc354695853569809">devel_node_access_node_access_explain()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3fe7744d74446e40e9b9ad2a782b4269"></a><!-- doxytag: member="node.api.php::hook_node_access_records" ref="ga3fe7744d74446e40e9b9ad2a782b4269" args="($node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hook_node_access_records </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set permissions for a node to be written to the database.</p>
<p>When a node is saved, a module implementing <a class="el" href="group__node__access.html#ga3fe7744d74446e40e9b9ad2a782b4269">hook_node_access_records()</a> will be asked if it is interested in the access permissions for a node. If it is interested, it must respond with an array of permissions arrays for that node.</p>
<p>Node access grants apply regardless of the published or unpublished status of the node. Implementations must make sure not to grant access to unpublished nodes if they don't want to change the standard access control behavior. Your module may need to create a separate access realm to handle access to unpublished nodes.</p>
<p>Note that the grant values in the return value from your hook must be integers and not boolean TRUE and FALSE.</p>
<p>Each permissions item in the array is an array with the following elements:</p>
<ul>
<li>'realm': The name of a realm that the module has defined in <a class="el" href="group__node__access.html#gaa973f2ab6ab14c3fa14e5138c6d69ecf">hook_node_grants()</a>.</li>
<li>'gid': A 'grant ID' from <a class="el" href="group__node__access.html#gaa973f2ab6ab14c3fa14e5138c6d69ecf">hook_node_grants()</a>.</li>
<li>'grant_view': If set to 1 a user that has been identified as a member of this gid within this realm can <a class="el" href="classview.html">view</a> this node. This should usually be set to $node-&gt;status. Failure to do so may expose unpublished content to some users.</li>
<li>'grant_update': If set to 1 a user that has been identified as a member of this gid within this realm can edit this node.</li>
<li>'grant_delete': If set to 1 a user that has been identified as a member of this gid within this realm can delete this node.</li>
<li>'priority': If multiple modules seek to set permissions on a node, the realms that have the highest priority will win out, and realms with a lower priority will not be written. If there is any doubt, it is best to leave this 0.</li>
</ul>
<p>When an implementation is interested in a node but want to deny access to everyone, it may return a "deny all" grant:</p>
<div class="fragment"><pre class="fragment"> $grants[] = array(
   <span class="stringliteral">&apos;realm&apos;</span> =&gt; <span class="stringliteral">&apos;all&apos;</span>,
   <span class="stringliteral">&apos;gid&apos;</span> =&gt; 0,
   <span class="stringliteral">&apos;grant_view&apos;</span> =&gt; 0,
   <span class="stringliteral">&apos;grant_update&apos;</span> =&gt; 0,
   <span class="stringliteral">&apos;grant_delete&apos;</span> =&gt; 0,
   <span class="stringliteral">&apos;priority&apos;</span> =&gt; 1,
 );
</pre></div><p>Setting the priority should cancel out other grants. In the case of a conflict between modules, it is safer to use <a class="el" href="group__node__access.html#ga37c90bf0e1dccad0deefa368dd94cc83">hook_node_access_records_alter()</a> to return only the deny grant.</p>
<p>Note: a deny all grant is not written to the database; denies are implicit.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__node__access.html#ga735fbb5dfa05cc1aed121655a1694909">node_access_write_grants()</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$node</em>&nbsp;</td><td>The node that has just been saved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An array of grants as defined above.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__node__access.html#ga37c90bf0e1dccad0deefa368dd94cc83">hook_node_access_records_alter()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga37c90bf0e1dccad0deefa368dd94cc83"></a><!-- doxytag: member="node.api.php::hook_node_access_records_alter" ref="ga37c90bf0e1dccad0deefa368dd94cc83" args="(&amp;$grants, $node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hook_node_access_records_alter </td>
          <td>(</td>
          <td class="paramtype">&amp;$&nbsp;</td>
          <td class="paramname"> <em>grants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Alter permissions for a node before it is written to the database.</p>
<p>Node access modules establish rules for user access to content. Node access records are stored in the {node_access} table and define which permissions are required to access a node. This hook is invoked after node access modules returned their requirements via <a class="el" href="group__node__access.html#ga3fe7744d74446e40e9b9ad2a782b4269">hook_node_access_records()</a>; doing so allows modules to modify the $grants array by reference before it is stored, so custom or advanced business logic can be applied.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__node__access.html#ga3fe7744d74446e40e9b9ad2a782b4269">hook_node_access_records()</a></dd></dl>
<p>Upon viewing, editing or deleting a node, <a class="el" href="group__node__access.html#gaa973f2ab6ab14c3fa14e5138c6d69ecf">hook_node_grants()</a> builds a permissions array that is compared against the stored access records. The user must have one or more matching permissions in order to complete the requested operation.</p>
<p>A module may deny all access to a node by setting $grants to an empty array.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__node__access.html#gaa973f2ab6ab14c3fa14e5138c6d69ecf">hook_node_grants()</a> </dd>
<dd>
<a class="el" href="group__node__access.html#ga21e95e2bd0b4ed12d861aa83426a8ba3">hook_node_grants_alter()</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$grants</em>&nbsp;</td><td>The $grants array returned by <a class="el" href="group__node__access.html#ga3fe7744d74446e40e9b9ad2a782b4269">hook_node_access_records()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$node</em>&nbsp;</td><td>The node for which the grants were acquired.</td></tr>
  </table>
  </dd>
</dl>
<p>The preferred use of this hook is in a module that bridges multiple node access modules with a configurable behavior, as shown in the example with the 'is_preview' field. </p>

</div>
</div>
<a class="anchor" id="gaa973f2ab6ab14c3fa14e5138c6d69ecf"></a><!-- doxytag: member="node.api.php::hook_node_grants" ref="gaa973f2ab6ab14c3fa14e5138c6d69ecf" args="($account, $op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hook_node_grants </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>op</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inform the node access system what permissions the user has.</p>
<p>This hook is for implementation by node access modules. In this hook, the module grants a user different "grant IDs" within one or more "realms". In <a class="el" href="group__node__access.html#ga3fe7744d74446e40e9b9ad2a782b4269">hook_node_access_records()</a>, the realms and grant IDs are associated with permission to <a class="el" href="classview.html">view</a>, edit, and delete individual nodes.</p>
<p>The realms and grant IDs can be arbitrarily defined by your node access module; it is common to use role IDs as grant IDs, but that is not required. Your module could instead maintain its own list of users, where each list has an ID. In that case, the return value of this hook would be an array of the list IDs that this user is a member of.</p>
<p>A node access module may implement as many realms as necessary to properly define the access privileges for the nodes. Note that the system makes no distinction between published and unpublished nodes. It is the module's responsibility to provide appropriate realms to limit access to unpublished content.</p>
<p>Node access records are stored in the {node_access} table and define which grants are required to access a node. There is a special case for the <a class="el" href="classview.html">view</a> operation -- a record with node ID 0 corresponds to a "view all" grant for the realm and grant ID of that record. If there are no node access modules enabled, the core node module adds a node ID 0 record for realm 'all'. Node access modules can also grant "view all" permission on their custom realms; for example, a module could create a record in {node_access} with: </p>
<div class="fragment"><pre class="fragment"> $record = array(
   <span class="stringliteral">&apos;nid&apos;</span> =&gt; 0,
   <span class="stringliteral">&apos;gid&apos;</span> =&gt; 888,
   <span class="stringliteral">&apos;realm&apos;</span> =&gt; <span class="stringliteral">&apos;example_realm&apos;</span>,
   <span class="stringliteral">&apos;grant_view&apos;</span> =&gt; 1,
   <span class="stringliteral">&apos;grant_update&apos;</span> =&gt; 0,
   <span class="stringliteral">&apos;grant_delete&apos;</span> =&gt; 0,
 );
 <a class="code" href="group__schemaapi.html#ga96f707de751a962bf21b6cb0cb4f2ae6">drupal_write_record</a>(<span class="stringliteral">&apos;node_access&apos;</span>, $record);
</pre></div><p> And then in its <a class="el" href="group__node__access.html#gaa973f2ab6ab14c3fa14e5138c6d69ecf">hook_node_grants()</a> implementation, it would need to return: </p>
<div class="fragment"><pre class="fragment"> <span class="keywordflow">if</span> ($op == <span class="stringliteral">&apos;view&apos;</span>) {
   $grants[<span class="stringliteral">&apos;example_realm&apos;</span>] = array(888);
 }
</pre></div><p> If you decide to do this, be aware that the <a class="el" href="group__node__access.html#gaf04007aedfc3afbe074b2fe4065ab618">node_access_rebuild()</a> function will erase any node ID 0 entry when it is called, so you will need to make sure to restore your {node_access} record after <a class="el" href="group__node__access.html#gaf04007aedfc3afbe074b2fe4065ab618">node_access_rebuild()</a> is called.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__node__access.html#gafb79200147d5087ceb32cb6b0632afd4">node_access_view_all_nodes()</a> </dd>
<dd>
<a class="el" href="group__node__access.html#gaf04007aedfc3afbe074b2fe4065ab618">node_access_rebuild()</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$account</em>&nbsp;</td><td>The user object whose grants are requested. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$op</em>&nbsp;</td><td>The node operation to be performed, such as 'view', 'update', or 'delete'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An array whose keys are "realms" of grants, and whose values are arrays of the grant IDs within this realm that this user is being granted.</dd></dl>
<p>For a detailed example, see node_access_example.module. </p>

</div>
</div>
<a class="anchor" id="ga21e95e2bd0b4ed12d861aa83426a8ba3"></a><!-- doxytag: member="node.api.php::hook_node_grants_alter" ref="ga21e95e2bd0b4ed12d861aa83426a8ba3" args="(&amp;$grants, $account, $op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hook_node_grants_alter </td>
          <td>(</td>
          <td class="paramtype">&amp;$&nbsp;</td>
          <td class="paramname"> <em>grants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>op</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Alter user access rules when trying to <a class="el" href="classview.html">view</a>, edit or delete a node.</p>
<p>Node access modules establish rules for user access to content. <a class="el" href="group__node__access.html#gaa973f2ab6ab14c3fa14e5138c6d69ecf">hook_node_grants()</a> defines permissions for a user to <a class="el" href="classview.html">view</a>, edit or delete nodes by building a $grants array that indicates the permissions assigned to the user by each node access module. This hook is called to allow modules to modify the $grants array by reference, so the interaction of multiple node access modules can be altered or advanced business logic can be applied.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__node__access.html#gaa973f2ab6ab14c3fa14e5138c6d69ecf">hook_node_grants()</a></dd></dl>
<p>The resulting grants are then checked against the records stored in the {node_access} table to determine if the operation may be completed.</p>
<p>A module may deny all access to a user by setting $grants to an empty array.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__node__access.html#ga3fe7744d74446e40e9b9ad2a782b4269">hook_node_access_records()</a> </dd>
<dd>
<a class="el" href="group__node__access.html#ga37c90bf0e1dccad0deefa368dd94cc83">hook_node_access_records_alter()</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$grants</em>&nbsp;</td><td>The $grants array returned by <a class="el" href="group__node__access.html#gaa973f2ab6ab14c3fa14e5138c6d69ecf">hook_node_grants()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$account</em>&nbsp;</td><td>The user account requesting access to content. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$op</em>&nbsp;</td><td>The operation being performed, 'view', 'update' or 'delete'.</td></tr>
  </table>
  </dd>
</dl>
<p>Developers may use this hook to either add additional grants to a user or to remove existing grants. These rules are typically based on either the permissions assigned to a user role, or specific attributes of a user account. </p>

</div>
</div>
<a class="anchor" id="ga46f0f1ed812befada8f8e7d1b8c352db"></a><!-- doxytag: member="node.module::node_access" ref="ga46f0f1ed812befada8f8e7d1b8c352db" args="($op, $node, $account=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">node_access </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>account</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines whether the current user may perform the operation on the node.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$op</em>&nbsp;</td><td>The operation to be performed on the node. Possible values are:</p>
<ul>
<li>"view"</li>
<li>"update"</li>
<li>"delete"</li>
<li>"create" </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$node</em>&nbsp;</td><td>The node object on which the operation is to be performed, or node type (e.g. 'forum') for "create" operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$account</em>&nbsp;</td><td>Optional, a user object representing the user for whom the operation is to be performed. Determines access for a user other than the current user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the operation may be performed, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6fbbc13a4098f72663c0a67f81100f67"></a><!-- doxytag: member="node.module::node_access_acquire_grants" ref="ga6fbbc13a4098f72663c0a67f81100f67" args="($node, $delete=TRUE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">node_access_acquire_grants </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>delete</em> = <code>TRUE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the list of node access grants and writes them to the database.</p>
<p>This function is called when a node is saved, and can also be called by modules if something other than a node save causes node access permissions to change. It collects all node access grants for the node from <a class="el" href="group__node__access.html#ga3fe7744d74446e40e9b9ad2a782b4269">hook_node_access_records()</a> implementations, allows these grants to be altered via <a class="el" href="group__node__access.html#ga37c90bf0e1dccad0deefa368dd94cc83">hook_node_access_records_alter()</a> implementations, and saves the collected and altered grants to the database.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$node</em>&nbsp;</td><td>The $node to acquire grants for.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$delete</em>&nbsp;</td><td>Whether to delete existing node access records before inserting new ones. Defaults to TRUE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab33de8c23b1edb657f67cb242a8ec8af"></a><!-- doxytag: member="node.module::node_access_grants" ref="gab33de8c23b1edb657f67cb242a8ec8af" args="($op, $account=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">node_access_grants </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>account</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetches an array of permission IDs granted to the given user ID.</p>
<p>The implementation here provides only the universal "all" grant. A node access module should implement <a class="el" href="group__node__access.html#gaa973f2ab6ab14c3fa14e5138c6d69ecf">hook_node_grants()</a> to provide a grant list for the user.</p>
<p>After the default grants have been loaded, we allow modules to alter the grants array by reference. This hook allows for complex business logic to be applied when integrating multiple node access modules.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$op</em>&nbsp;</td><td>The operation that the user is trying to perform. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$account</em>&nbsp;</td><td>The user object for the user performing the operation. If omitted, the current user is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An associative array in which the keys are realms, and the values are arrays of grants for those realms. </dd></dl>

</div>
</div>
<a class="anchor" id="ga895d95595168709334c4eca1472c6d23"></a><!-- doxytag: member="node.module::node_access_needs_rebuild" ref="ga895d95595168709334c4eca1472c6d23" args="($rebuild=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">node_access_needs_rebuild </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>rebuild</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flags or unflags the node access grants for rebuilding.</p>
<p>If the argument isn't specified, the current value of the flag is returned. When the flag is set, a message is displayed to users with 'access administration pages' permission, pointing to the 'rebuild' confirm form. This can be used as an alternative to direct node_access_rebuild calls, allowing administrators to decide when they want to perform the actual (possibly time consuming) rebuild. When unsure if the current user is an administrator, <a class="el" href="group__node__access.html#gaf04007aedfc3afbe074b2fe4065ab618">node_access_rebuild()</a> should be used instead.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$rebuild</em>&nbsp;</td><td>(Optional) The boolean value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current value of the flag if no value was provided for $rebuild.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__node__access.html#gaf04007aedfc3afbe074b2fe4065ab618">node_access_rebuild()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf04007aedfc3afbe074b2fe4065ab618"></a><!-- doxytag: member="node.module::node_access_rebuild" ref="gaf04007aedfc3afbe074b2fe4065ab618" args="($batch_mode=FALSE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">node_access_rebuild </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>batch_mode</em> = <code>FALSE</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rebuilds the node access database.</p>
<p>This is occasionally needed by modules that make system-wide changes to access levels. When the rebuild is required by an admin-triggered action (e.g module settings form), calling node_access_needs_rebuild(TRUE) instead of <a class="el" href="group__node__access.html#gaf04007aedfc3afbe074b2fe4065ab618">node_access_rebuild()</a> lets the user perform his changes and actually rebuild only once he is done.</p>
<p>Note: As of Drupal 6, node access modules are not required to (and actually should not) call <a class="el" href="group__node__access.html#gaf04007aedfc3afbe074b2fe4065ab618">node_access_rebuild()</a> in hook_enable/disable anymore.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__node__access.html#ga895d95595168709334c4eca1472c6d23">node_access_needs_rebuild()</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$batch_mode</em>&nbsp;</td><td>Set to TRUE to process in 'batch' mode, spawning processing over several HTTP requests (thus avoiding the risk of PHP timeout if the site has a large number of nodes). hook_update_N and any form submit handler are safe contexts to use the 'batch mode'. Less decidable cases (such as calls from hook_user, hook_taxonomy, etc...) might consider using the non-batch mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafb79200147d5087ceb32cb6b0632afd4"></a><!-- doxytag: member="node.module::node_access_view_all_nodes" ref="gafb79200147d5087ceb32cb6b0632afd4" args="($account=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">node_access_view_all_nodes </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>account</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines whether the user has a global viewing grant for all nodes.</p>
<p>Checks to see whether any module grants global 'view' access to a user account; global 'view' access is encoded in the {node_access} table as a grant with nid=0. If no node access modules are enabled, <a class="el" href="node_8module.html">node.module</a> defines such a global 'view' access grant.</p>
<p>This function is called when a node listing query is tagged with 'node_access'; when this function returns TRUE, no node access joins are added to the query.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$account</em>&nbsp;</td><td>The user object for the user whose access is being checked. If omitted, the current user is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if 'view' access to all nodes is granted, FALSE otherwise.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__node__access.html#gaa973f2ab6ab14c3fa14e5138c6d69ecf">hook_node_grants()</a> </dd>
<dd>
<a class="el" href="group__node__access.html#ga5f4838d9b5cac9f3bee9a26f39e80691">_node_query_node_access_alter()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga735fbb5dfa05cc1aed121655a1694909"></a><!-- doxytag: member="node.module::node_access_write_grants" ref="ga735fbb5dfa05cc1aed121655a1694909" args="($node, $grants, $realm=NULL, $delete=TRUE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">node_access_write_grants </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>grants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>realm</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>delete</em> = <code>TRUE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes a list of grants to the database, deleting any previously saved ones.</p>
<p>If a realm is provided, it will only delete grants from that realm, but it will always delete a grant from the 'all' realm. Modules that utilize <a class="el" href="group__node__access.html#ga46f0f1ed812befada8f8e7d1b8c352db">node_access()</a> can use this function when doing mass updates due to widespread permission changes.</p>
<p>Note: Don't call this function directly from a contributed module. Call <a class="el" href="group__node__access.html#ga6fbbc13a4098f72663c0a67f81100f67">node_access_acquire_grants()</a> instead.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$node</em>&nbsp;</td><td>The node whose grants are being written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$grants</em>&nbsp;</td><td>A list of grants to write. Each grant is an array that must contain the following keys: realm, gid, grant_view, grant_update, grant_delete. The realm is specified by a particular module; the gid is as well, and is a module-defined id to define grant privileges. each grant_* field is a boolean value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$realm</em>&nbsp;</td><td>(optional) If provided, read/write grants for that realm only. Defaults to NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$delete</em>&nbsp;</td><td>(optional) If false, does not delete records. This is only for optimization purposes, and assumes the caller has already performed a mass delete of some form. Defaults to TRUE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__node__access.html#ga6fbbc13a4098f72663c0a67f81100f67">node_access_acquire_grants()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga929efd16564e3cb073ee5e1ed6c6c2a7"></a><!-- doxytag: member="node.module::node_list_permissions" ref="ga929efd16564e3cb073ee5e1ed6c6c2a7" args="($type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">node_list_permissions </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>type</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper function to generate standard node permission list for a given type.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$type</em>&nbsp;</td><td>The machine-readable name of the node type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>array An array of permission names and descriptions. </dd></dl>

</div>
</div>
<a class="anchor" id="gae826daeafed8b20300a370c2022cc2c1"></a><!-- doxytag: member="node.module::node_node_access" ref="gae826daeafed8b20300a370c2022cc2c1" args="($node, $op, $account)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">node_node_access </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>account</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Implements <a class="el" href="group__node__access.html#ga75a280ea1fbe0fb6ca034f8aad06d58d">hook_node_access()</a>. </p>

</div>
</div>
<a class="anchor" id="ga75960e1cc5852c75c6347ab938938f9b"></a><!-- doxytag: member="node.module::node_permissions_get_configured_types" ref="ga75960e1cc5852c75c6347ab938938f9b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">node_permissions_get_configured_types </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns an array of node types that should be managed by permissions.</p>
<p>By default, this will include all node types in the system. To exclude a specific node from getting permissions defined for it, set the node_permissions_$type variable to 0. Core does not provide an interface for doing so. However, contrib modules may exclude their own nodes in <a class="el" href="group__hooks.html#ga1ecdb5a2a046ea63dc790c3ed90338e5">hook_install()</a>. Alternatively, contrib modules may configure all node types at once, or decide to apply some other <a class="el" href="group__node__access.html#ga75a280ea1fbe0fb6ca034f8aad06d58d">hook_node_access()</a> implementation to some or all node types.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An array of node types managed by this module. </dd></dl>

</div>
</div>
<a class="anchor" id="gacd4162ac9ee2d2147d5212fd5e7a7319"></a><!-- doxytag: member="node.module::node_query_entity_field_access_alter" ref="gacd4162ac9ee2d2147d5212fd5e7a7319" args="(QueryAlterableInterface $query)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">node_query_entity_field_access_alter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceQueryAlterableInterface.html">QueryAlterableInterface</a> $&nbsp;</td>
          <td class="paramname"> <em>query</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Implements <a class="el" href="group__hooks.html#ga12527037deeb76adcab1000e984fdfce">hook_query_TAG_alter()</a>.</p>
<p>This function implements the same functionality as <a class="el" href="group__node__access.html#gaef7c83544718b8431d81b884ef8cc6f5">node_query_node_access_alter()</a> for the SQL field storage engine. Node access conditions are added for field values belonging to nodes only. </p>

</div>
</div>
<a class="anchor" id="gaef7c83544718b8431d81b884ef8cc6f5"></a><!-- doxytag: member="node.module::node_query_node_access_alter" ref="gaef7c83544718b8431d81b884ef8cc6f5" args="(QueryAlterableInterface $query)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">node_query_node_access_alter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceQueryAlterableInterface.html">QueryAlterableInterface</a> $&nbsp;</td>
          <td class="paramname"> <em>query</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Implements <a class="el" href="group__hooks.html#ga12527037deeb76adcab1000e984fdfce">hook_query_TAG_alter()</a>.</p>
<p>This is the <a class="el" href="group__hooks.html#gaf166f6375e9f7b5919d719eb91198d47">hook_query_alter()</a> for queries tagged with 'node_access'. It adds node access checks for the user account given by the 'account' meta-data (or global $user if not provided), for an operation given by the 'op' meta-data (or 'view' if not provided; other possible values are 'update' and 'delete'). </p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 8 Nov 2013 for DoSomething.org by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
